# LOAD & STORE 명령어 디자인

## LOAD & STORE 명령어의 필요성

- 명령어를 디자인 하는 과정에서 사칙 연산 결과를 레지스터에만 저장할 수 있게 제약 사항을 둠
- 즉, 피연산자로 올 수 있는 것은 숫자와 레지스터임

그래서 다음과 같은 연산을 할 수 가 없다.
```c
int a = 10; // 0x10 번지 할당
int b = 20; // 0x20 번지 할당
int c = 0; // 0x30 번지 할당
c = a + b;
```

여기서 c = a+ b 연산을 실행하기 위해서

다음과 같은 명령어로 문장을 구성 해야 한다.

`"0x10번지(a)에 저장된 값과 , 0x20 번지 (b)에 저장된 값을 더해서 0x30 번지(c)에 저장해라`

하지만 메인 메모리 주소 정보를 사칙 연산의 피연산자로 올 수 있도록 명령어 구조를 설계하지 않았다.
( RISC (Reduced Instruction Set Computer) 방식 )

왜?? 메모리 주소가 오게 할 수 있지만 명령어 구조가 복잡해지고 이에 따라 하드웨어 구성도 복잡해지기 때문에
성능이 저하 될 수 있다. 

CISC (Complex Instriction Set Computer) 방식이면 가능하다.

따라서 메인 메모리에 저장된 데이터를 레지스터로 일단 옮겨다 놓은 다음에
덧셈을 진행해야 한다. 레지스터와 메인 메모리 사이에서 데이터를 전송할 수 있는 명령어가 필요하다.



![img.png](img.png)

메인 메모리에 저장된 데이터를 레지스터로 이동시키기 위한 LOAD 명령어와,
레지스터에 저장된 데이터를 메인 메모리로 이동시키기 위한 위한 STORE 명령어가 필요하다.

![img_1.png](img_1.png)


```asm
LOAD r1 , 0x10    // 0x10 번지에 존재하는 데이터를 레지스터 r3에 저장하라
LOAD r2 , 0x20   //0x20 번지에 존재하는 데이터르 레지스터 r2에 저장하라
ADD r3 , r1 ,r2   // r1 , r2에 저장된 값을 더해서 r3에 결과를 저장해라
STORE r3, 0x30   // r3에 저장된 값을 0x30번지에 저장해라
```

![img_2.png](img_2.png)


### `RISC vs CISC`

명령어 종류가 많고, 다양한 조합이 가능한 CPU도 있다. 명령어 개수가 세 자리 수를 넘지 않은 
CPU 도 있고 수 백개의 명령어 구성이 가능한 CPU도 있다. 

명령어 종류가 많으면 (다양한 조합이 가능) 프로그램을 구현하는 데 편리함을 가져다 준다.
수십 줄에 걸쳐서 구현해야 하는 기능을 단 한 줄로 완성시킬 수 있고 필요에 따라서
명령어 길이도 유동적이기 때문에 메모리를 효율적으로 사용할 수 있다.

이것은 CISC 구조 CPU의 특징이다. 
CISC 는 "Complex Instruction Set Computer" 의 약자로 복잡한 명령어체계를 가지는
컴퓨러를 의미한다.  CISC는 명령어 수가 많고 그 크기가 일정치 않기 때문에 CPU 가 복잡해질 수 밖에 없다.
이러한 복잡한 구조는 성능 향상에 제한이 따른다. 보다 높은 성능의 CPU를 디자인하기 위해서
보다 단순한 CPU 구조가 필요하다.

